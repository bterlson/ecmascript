<es-clause title="Reflection" anchor="sec-reflection">
  <es-clause title="The Reflect Object" anchor="sec-reflect-object">
    <p>The Reflect object is a single ordinary object.</p>

    <p>The value of the [[Prototype]] <es-xref target=
    "sec-object-internal-methods-and-internal-slots">internal slot</es-xref> of the Reflect object
    is the standard built-in Object prototype object (<es-xref target=
    "sec-properties-of-the-object-prototype-object">19.1.3</es-xref>).</p>

    <p>The Reflect object is not a function object. It does not have a [[Construct]] internal
    method; it is not possible to use the Reflect object as a constructor with the <code>new</code>
    operator. The Reflect object also does not have a [[Call]] internal method; it is not possible
    to invoke the Reflect object as a function.</p>

    <es-clause title="Reflect.defineProperty(target, propertyKey, attributes)" anchor=
    "sec-reflect.defineproperty">
      <p>When the <code>defineProperty</code> function is called with arguments <i>target</i>,
      <i>propertyKey</i>, and <es-nt>attributes</es-nt> the following steps are taken:</p>

      <ol class="proc">
        <li>Let <i>obj</i> be <es-xref target=
        "sec-toobject">ToObject</es-xref>(<i>target</i>).</li>

        <li><es-xref target="sec-returnifabrupt">ReturnIfAbrupt</es-xref>(<i>obj</i>).</li>

        <li>Let <i>key</i> be <es-xref target=
        "sec-topropertykey">ToPropertyKey</es-xref>(<i>propertyKey</i>).</li>

        <li><es-xref target="sec-returnifabrupt">ReturnIfAbrupt</es-xref>(<i>key</i>).</li>

        <li>Let <i>desc</i> be the result of calling <es-xref target=
        "sec-topropertydescriptor">ToPropertyDescriptor</es-xref> with <i>attributes</i> as the
        argument.</li>

        <li><es-xref target="sec-returnifabrupt">ReturnIfAbrupt</es-xref>(<i>desc</i>).</li>

        <li>Return the result of calling the [[DefineOwnProperty]] internal method of <i>obj</i>
        with arguments <i>key</i>, and <i>desc</i>.</li>
      </ol>
    </es-clause>

    <es-clause title="Reflect.deleteProperty (target, propertyKey)" anchor=
    "sec-reflect.deleteproperty">
      <p>When the <code>deleteProperty</code> function is called with arguments <i>target</i> and
      <i>propertyKey</i>, the following steps are taken:</p>

      <ol class="proc">
        <li>Let <i>obj</i> be <es-xref target=
        "sec-toobject">ToObject</es-xref>(<i>target</i>).</li>

        <li><es-xref target="sec-returnifabrupt">ReturnIfAbrupt</es-xref>(<i>obj</i>).</li>

        <li>Let <i>key</i> be <es-xref target=
        "sec-topropertykey">ToPropertyKey</es-xref>(<i>propertyKey</i>).</li>

        <li><es-xref target="sec-returnifabrupt">ReturnIfAbrupt</es-xref>(<i>key</i>).</li>

        <li>Return the result of calling the [[Delete]] internal method of <i>obj</i> with argument
        <i>key</i>.</li>
      </ol>
    </es-clause>

    <es-clause title="Reflect.enumerate (target)" anchor="sec-reflect.enumerate">
      <p>When the <code>enumerate</code> function is called with argument <es-nt>target</es-nt> the
      following steps are taken:</p>

      <ol class="proc">
        <li>Let <i>obj</i> be <es-xref target=
        "sec-toobject">ToObject</es-xref>(<i>target</i>).</li>

        <li><es-xref target="sec-returnifabrupt">ReturnIfAbrupt</es-xref>(<i>obj</i>).</li>

        <li>Let <i>iterator</i> be the result of calling the [[Enumerate]] internal method of
        <i>obj</i>.</li>

        <li>Return <i>iterator</i>.</li>
      </ol>
    </es-clause>

    <es-clause title="Reflect.get (target, propertyKey, receiver=target)" anchor="sec-reflect.get">
      <p>When the <code>get</code> function is called with arguments <i>target</i>,
      <i>propertyKey</i>, and <es-nt>receiver</es-nt> the following steps are taken:</p>

      <ol class="proc">
        <li>Let <i>obj</i> be <es-xref target=
        "sec-toobject">ToObject</es-xref>(<i>target</i>).</li>

        <li><es-xref target="sec-returnifabrupt">ReturnIfAbrupt</es-xref>(<i>obj</i>).</li>

        <li>Let <i>key</i> be <es-xref target=
        "sec-topropertykey">ToPropertyKey</es-xref>(<i>propertyKey</i>).</li>

        <li><es-xref target="sec-returnifabrupt">ReturnIfAbrupt</es-xref>(<i>key</i>).</li>

        <li>If <i>receiver</i> is not present, then

          <ol class="block">
            <li>Let <i>receiver</i> be <i>target</i>.</li>
          </ol>
        </li>

        <li>Return the result of calling the [[Get]] internal method of <i>obj</i> with arguments
        <i>key</i>, and <i>receiver</i>.</li>
      </ol>
    </es-clause>

    <es-clause title="Reflect.getOwnPropertyDescriptor(target, propertyKey)" anchor=
    "sec-reflect.getownpropertydescriptor">
      <p>When the <code>getOwnPropertyDescriptor</code> function is called with arguments
      <i>target</i> and <i>propertyKey</i>, the following steps are taken:</p>

      <ol class="proc">
        <li>Let <i>obj</i> be <es-xref target=
        "sec-toobject">ToObject</es-xref>(<i>target</i>).</li>

        <li><es-xref target="sec-returnifabrupt">ReturnIfAbrupt</es-xref>(<i>obj</i>).</li>

        <li>Let <i>key</i> be <es-xref target=
        "sec-topropertykey">ToPropertyKey</es-xref>(<i>propertyKey</i>).</li>

        <li><es-xref target="sec-returnifabrupt">ReturnIfAbrupt</es-xref>(<i>key</i>).</li>

        <li>Let <i>desc</i> be the result of calling the [[GetOwnProperty]] internal method of
        <i>obj</i> with argument <i>key</i>.</li>

        <li><es-xref target="sec-returnifabrupt">ReturnIfAbrupt</es-xref>(<i>desc</i>).</li>

        <li>Return the result of calling <es-xref target=
        "sec-frompropertydescriptor">FromPropertyDescriptor</es-xref>(<i>desc</i>).</li>
      </ol>
    </es-clause>

    <es-clause title="Reflect.getPrototypeOf (target)" anchor="sec-reflect.getprototypeof">
      <p>When the <code>getPrototypeOf</code> function is called with argument
      <es-nt>target</es-nt> the following steps are taken:</p>

      <ol class="proc">
        <li>Let <i>obj</i> be <es-xref target=
        "sec-toobject">ToObject</es-xref>(<i>target</i>).</li>

        <li><es-xref target="sec-returnifabrupt">ReturnIfAbrupt</es-xref>(<i>obj</i>).</li>

        <li>Return the result of calling the [[GetPrototypeOf]] internal method of <i>obj</i>.</li>
      </ol>
    </es-clause>

    <es-clause title="Reflect.has (target, propertyKey)" anchor="sec-reflect.has">
      <p>When the <code>has</code> function is called with arguments <i>target</i> and
      <i>propertyKey</i>, the following steps are taken:</p>

      <ol class="proc">
        <li>Let <i>obj</i> be <es-xref target=
        "sec-toobject">ToObject</es-xref>(<i>target</i>).</li>

        <li><es-xref target="sec-returnifabrupt">ReturnIfAbrupt</es-xref>(<i>obj</i>).</li>

        <li>Let <i>key</i> be <es-xref target=
        "sec-topropertykey">ToPropertyKey</es-xref>(<i>propertyKey</i>).</li>

        <li><es-xref target="sec-returnifabrupt">ReturnIfAbrupt</es-xref>(<i>key</i>).</li>

        <li>Return the result of calling the [[HasProperty]] internal method of <i>obj</i> with
        argument <i>key</i>.</li>
      </ol>
    </es-clause>

    <es-clause title="Reflect.hasOwn (target, propertyKey)" anchor="sec-reflect.hasown">
      <p>When the <code>hasOwn</code> function is called with arguments <i>target</i> and
      <i>propertyKey</i>, the following steps are taken:</p>

      <ol class="proc">
        <li>Let <i>obj</i> be <es-xref target=
        "sec-toobject">ToObject</es-xref>(<i>target</i>).</li>

        <li><es-xref target="sec-returnifabrupt">ReturnIfAbrupt</es-xref>(<i>obj</i>).</li>

        <li>Let <i>key</i> be <es-xref target=
        "sec-topropertykey">ToPropertyKey</es-xref>(<i>propertyKey</i>).</li>

        <li><es-xref target="sec-returnifabrupt">ReturnIfAbrupt</es-xref>(<i>key</i>).</li>

        <li>Return the result of <es-xref target=
        "sec-hasownproperty">HasOwnProperty</es-xref>(<i>obj</i>, <i>key</i>).</li>
      </ol>
    </es-clause>

    <es-clause title="Reflect.isExtensible (target)" anchor="sec-reflect.isextensible">
      <p>When the <code>isExtensible</code> function is called with argument <es-nt>target</es-nt>
      the following steps are taken:</p>

      <ol class="proc">
        <li>Let <i>obj</i> be <es-xref target=
        "sec-toobject">ToObject</es-xref>(<i>target</i>).</li>

        <li><es-xref target="sec-returnifabrupt">ReturnIfAbrupt</es-xref>(<i>obj</i>).</li>

        <li>Return the result of calling the [[IsExtensible]] internal method of <i>obj</i>.</li>
      </ol>
    </es-clause>

    <es-clause title="Reflect.ownKeys (target)" anchor="sec-reflect.ownkeys">
      <p>When the <code>ownKeys</code> function is called with argument <es-nt>target</es-nt> the
      following steps are taken:</p>

      <ol class="proc">
        <li>Let <i>obj</i> be <es-xref target=
        "sec-toobject">ToObject</es-xref>(<i>target</i>).</li>

        <li><es-xref target="sec-returnifabrupt">ReturnIfAbrupt</es-xref>(<i>obj</i>).</li>

        <li>Return the result of calling the [[OwnPropertyKeys]] internal method of
        <i>obj</i>.</li>
      </ol>
    </es-clause>

    <es-clause title="Reflect.preventExtensions (target)" anchor="sec-reflect.preventextensions">
      <p>When the <code>preventExtensions</code> function is called with argument
      <es-nt>target</es-nt>, the following steps are taken:</p>

      <ol class="proc">
        <li>Let <i>obj</i> be <es-xref target=
        "sec-toobject">ToObject</es-xref>(<i>target</i>).</li>

        <li><es-xref target="sec-returnifabrupt">ReturnIfAbrupt</es-xref>(<i>obj</i>).</li>

        <li>Return the result of calling the [[PreventExtensions]] internal method of
        <i>obj</i>.</li>
      </ol>
    </es-clause>

    <es-clause title="Reflect.set (target, propertyKey, V, receiver=target)" anchor=
    "sec-reflect.set">
      <p>When the <code>set</code> function is called with arguments <i>target</i>, <i>V</i>,
      <i>propertyKey</i>, and <es-nt>receiver</es-nt> the following steps are taken:</p>

      <ol class="proc">
        <li>Let <i>obj</i> be <es-xref target=
        "sec-toobject">ToObject</es-xref>(<i>target</i>).</li>

        <li><es-xref target="sec-returnifabrupt">ReturnIfAbrupt</es-xref>(<i>obj</i>).</li>

        <li>Let <i>key</i> be <es-xref target=
        "sec-topropertykey">ToPropertyKey</es-xref>(<i>propertyKey</i>).</li>

        <li><es-xref target="sec-returnifabrupt">ReturnIfAbrupt</es-xref>(<i>key</i>).</li>

        <li>If <i>receiver</i> is not present, then

          <ol class="block">
            <li>Let <i>receiver</i> be <i>target</i>.</li>
          </ol>
        </li>

        <li>Return the result of calling the [[Set]] internal method of <i>obj</i> with arguments
        <i>key</i>, <i>V</i>, and <i>receiver</i>.</li>
      </ol>
    </es-clause>

    <es-clause title="Reflect.setPrototypeOf (target, proto)" anchor="sec-reflect.setprototypeof">
      <p>When the <code>setPrototypeOf</code> function is called with arguments <i>target</i> and
      <i>propertyKey</i>, the following steps are taken:</p>

      <ol class="proc">
        <li>Let <i>obj</i> be <es-xref target=
        "sec-toobject">ToObject</es-xref>(<i>target</i>).</li>

        <li><es-xref target="sec-returnifabrupt">ReturnIfAbrupt</es-xref>(<i>obj</i>).</li>

        <li>If <es-xref target="sec-ecmascript-data-types-and-values">Type</es-xref>(<i>proto</i>)
        is not Object and <i>proto</i> is not <b>null</b>, then throw a <b>TypeError</b>
        exception</li>

        <li>Return the result of calling the [[SetPrototypeOf]] internal method of <i>obj</i> with
        argument <i>proto</i>.</li>
      </ol>
    </es-clause>
  </es-clause>

  <es-clause title="Proxy Objects" anchor="sec-proxy-objects">
    <es-clause title="The Proxy Factory Function" anchor="sec-proxy-factory-function">
      <es-clause title="Proxy ( target, handler)" anchor="sec-proxy-target-handler">
        <p>The <code>Proxy</code> function is used to create an irrevocable Proxy object. When
        <code>Proxy</code> is called with arguments <es-nt>target</es-nt> and
        <es-nt>handler</es-nt> the following steps are taken:</p>

        <ol class="proc">
          <li>Let <i>p</i> be <es-xref target=
          "sec-proxycreate">ProxyCreate</es-xref>(<i>target</i>, <i>handler</i>).</li>

          <li>Return <i>p</i>.</li>
        </ol>
      </es-clause>
    </es-clause>

    <es-clause title="Properties of the Proxy Factory Function" anchor=
    "sec-properties-of-the-proxy-factory-function">
      <es-clause title="Proxy.revocable ( target, handler )" anchor="sec-proxy.revocable">
        <p>The <code>Proxy.revocable</code> function is used to create a revocable Proxy object.
        When <code>Proxy.revocable</code> is called with arguments <es-nt>target</es-nt> and
        <es-nt>handler</es-nt> the following steps are taken:</p>

        <ol class="proc">
          <li>Let <i>p</i> be <es-xref target=
          "sec-proxycreate">ProxyCreate</es-xref>(<i>target</i>, <i>handler</i>).</li>

          <li><es-xref target="sec-returnifabrupt">ReturnIfAbrupt</es-xref>(<i>p</i>).</li>

          <li>Let <i>revoker</i> be a new built-in function object as defined in <es-xref target=
          "sec-proxy-revocation-functions">26.2.2.1.1</es-xref>.</li>

          <li>Set the [[RevokableProxy]] <es-xref target=
          "sec-object-internal-methods-and-internal-slots">internal slot</es-xref> of
          <i>revoker</i> to <i>p</i>.</li>

          <li>Let <i>result</i> be the result of <es-xref target=
          "sec-objectcreate">ObjectCreate</es-xref>().</li>

          <li><es-xref target="sec-createdataproperty">CreateDataProperty</es-xref>(<i>result</i>,
          <code>"proxy"</code>, <i>p</i>).</li>

          <li><es-xref target="sec-createdataproperty">CreateDataProperty</es-xref>(<i>result</i>,
          <code>"revoke"</code>, <i>revoker</i>).</li>

          <li>Return <i>result</i>.</li>
        </ol>

        <es-clause title="Proxy Revocation Functions" anchor="sec-proxy-revocation-functions">
          <p>A Proxy revocation function is an anonymous function that has the ability to
          invalidate a specific Proxy object.</p>

          <p>Each Proxy revocation function has a [[RevokableProxy]] <es-xref target=
          "sec-object-internal-methods-and-internal-slots">internal slot</es-xref>.</p>

          <p>When a Proxy revocation function, <es-nt>F</es-nt>, is called the following steps are
          taken:</p>

          <ol class="proc">
            <li>Let <i>p</i> be the value of <i>F</i>’s [[RevokableProxy]] <es-xref target=
            "sec-object-internal-methods-and-internal-slots">internal slot</es-xref>.</li>

            <li>If <i>p</i> is <b>null</b>, then return <b>undefined</b>.</li>

            <li>Set the value of <i>F</i>’s [[RevokableProxy]] <es-xref target=
            "sec-object-internal-methods-and-internal-slots">internal slot</es-xref> to
            <b>null</b>.</li>

            <li><es-xref target="sec-algorithm-conventions">Assert</es-xref>: <i>p</i> is a Proxy
            object.</li>

            <li>Set the [[ProxyTarget]] <es-xref target=
            "sec-object-internal-methods-and-internal-slots">internal slot</es-xref> of <i>p</i> to
            <b>null</b>.</li>

            <li>Set the [[ProxyHandler]] <es-xref target=
            "sec-object-internal-methods-and-internal-slots">internal slot</es-xref> of <i>p</i> to
            <b>null</b>.</li>

            <li>Return <b>undefined</b>.</li>
          </ol>
        </es-clause>
      </es-clause>
    </es-clause>
  </es-clause>
</es-clause>
