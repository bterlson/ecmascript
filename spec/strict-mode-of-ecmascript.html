<es-clause title="The Strict Mode of ECMAScript" anchor="sec-strict-mode-of-ecmascript">
  <p><b>The strict mode restriction and exceptions</b></p>

  <ul>
    <li>
      <p>The identifiers "<code>implements</code>", "<code>interface</code>", "<code>let</code>",
      "<code>package</code>", "<code>private</code>", "<code>protected</code>",
      "<code>public</code>", "<code>static</code>", and "<code>yield</code>" are classified as
      <i>FutureReservedWord</i> tokens within <es-xref target="sec-strict-mode-code">strict mode
      code</es-xref>. (<es-xref target="sec-future-reserved-words">11.6.2.2</es-xref>).</p>
    </li>

    <li>
      <p>A conforming implementation, when processing <es-xref target="sec-strict-mode-code">strict
      mode code</es-xref>, may not extend the syntax of <i>NumericLiteral</i> (<es-xref target=
      "sec-literals-numeric-literals">11.8.3</es-xref>) to include <i>LegacyOctalIntegerLiteral</i>
      as described in <es-xref target="sec-additional-syntax-numeric-literals">B.1.1</es-xref>.</p>
    </li>

    <li>
      <p>A conforming implementation, when processing <es-xref target="sec-strict-mode-code">strict
      mode code</es-xref> (see <es-xref target="sec-strict-mode-code">10.2.1</es-xref>), may not
      extend the syntax of <i>EscapeSequence</i> to include <i>LegacyOctalEscapeSequence</i> as
      described in <es-xref target="sec-additional-syntax-string-literals">B.1.2</es-xref>.</p>
    </li>

    <li>
      <p>Assignment to an undeclared identifier or otherwise unresolvable reference does not create
      a property in the global object. When a simple assignment occurs within <es-xref target=
      "sec-strict-mode-code">strict mode code</es-xref>, its <i>LeftHandSide</i> must not evaluate
      to an <es-xref target="sec-reference-specification-type">unresolvable Reference</es-xref>. If
      it does a <b>ReferenceError</b> exception is thrown (<es-xref target=
      "sec-putvalue">6.2.3.2</es-xref>). The <i>LeftHandSide</i> also may not be a reference to a
      data property with the attribute value {[[Writable]]:<b>false</b>}, to an accessor property
      with the attribute value {[[Set]]:<b>undefined</b>}, nor to a non-existent property of an
      object whose [[Extensible]] <es-xref target=
      "sec-object-internal-methods-and-internal-slots">internal slot</es-xref> has the value
      <b>false</b>. In these cases a <code>TypeError</code> exception is thrown (<es-xref target=
      "sec-assignment-operators">12.13</es-xref>).</p>
    </li>

    <li>
      <p>The identifier <code>eval</code> or <code>arguments</code> may not appear as the
      <i>LeftHandSideExpression</i> of an Assignment operator (<es-xref target=
      "sec-assignment-operators">12.13</es-xref>) or of a <i>PostfixExpression</i>
      (<es-xref target="sec-assignment-operators">12.13</es-xref>) or as the <i>UnaryExpression</i>
      operated upon by a Prefix Increment (<es-xref target=
      "sec-prefix-increment-operator">12.4.7</es-xref>) or a Prefix Decrement (<es-xref target=
      "sec-prefix-decrement-operator">12.4.8</es-xref>) operator.</p>
    </li>

    <li>
      <p>Arguments objects for strict mode functions define non-configurable accessor properties
      named "<code>caller</code>" and "<code>callee</code>" which throw a <b>TypeError</b>
      exception on access (<es-xref target=
      "sec-addrestrictedfunctionproperties">9.2.8</es-xref>).</p>
    </li>

    <li>
      <p>Arguments objects for strict mode functions do not dynamically share their array indexed
      property values with the corresponding formal parameter bindings of their functions.
      (<es-xref target="sec-arguments-object">9.4.4.1</es-xref>).</p>
    </li>

    <li>
      <p>For strict mode functions, if an arguments object is created the binding of the local
      identifier <code>arguments</code> to the arguments object is immutable and hence may not be
      the target of an assignment expression. (<es-xref target=
      "sec-arguments-object">9.4.4.1</es-xref>).</p>
    </li>

    <li>
      <p>It is a <b>SyntaxError</b> if <es-xref target="sec-strict-mode-code">strict mode
      code</es-xref> contains an <i>ObjectLiteral</i> with more than one definition of any data
      property (<es-xref target="sec-object-initialiser">12.1.5</es-xref>).</p>
    </li>

    <li>
      <p>It is a <b>SyntaxError</b> if the <i>Identifier</i> <code>"eval"</code> or the
      <i>Identifier</i> <code>"arguments"</code> occurs as the <i>Identifier</i> in a
      <es-nt>PropertySetParameterList</es-nt> of a <es-nt>PropertyDefinition</es-nt> that is
      contained in <es-xref target="sec-strict-mode-code">strict code</es-xref> or if its
      <i>FunctionBody</i> is <es-xref target="sec-strict-mode-code">strict code</es-xref>
      (<es-xref target="sec-object-initialiser">12.1.5</es-xref>).</p>
    </li>

    <li>
      <p>Strict mode eval code cannot instantiate variables or functions in the variable
      environment of the caller to eval. Instead, a new variable environment is created and that
      environment is used for declaration binding instantiation for the eval code (<es-xref target=
      "sec-eval-x">18.2.1</es-xref>).</p>
    </li>

    <li>
      <p>If <b>this</b> is evaluated within <es-xref target="sec-strict-mode-code">strict mode
      code</es-xref>, then the <b>this</b> value is not coerced to an object. A <b>this</b> value
      of <b>null</b> or <b>undefined</b> is not converted to the global object and primitive values
      are not converted to wrapper objects. The <b>this</b> value passed via a function call
      (including calls made using <code><es-xref target=
      "sec-function.prototype.apply">Function.prototype.apply</es-xref></code> and
      <b><es-xref target="sec-function.prototype.call">Function.prototype.call</es-xref>)</b> do
      not coerce the passed this value to an object (<es-xref target=
      "sec-getthisenvironment">8.3.2</es-xref>, <es-xref target=
      "sec-this-keyword">12.1.1</es-xref>, <es-xref target=
      "sec-function.prototype.call">19.2.3.3</es-xref>, 0).</p>
    </li>

    <li>
      <p>When a <code>delete</code> operator occurs within <es-xref target=
      "sec-strict-mode-code">strict mode code</es-xref>, a <b>SyntaxError</b> is thrown if its
      <i>UnaryExpression</i> is a direct reference to a variable, function argument, or function
      name(<es-xref target="sec-delete-operator">12.4.4</es-xref>).</p>
    </li>

    <li>
      <p>When a <code>delete</code> operator occurs within <es-xref target=
      "sec-strict-mode-code">strict mode code</es-xref>, a <b>TypeError</b> is thrown if the
      property to be deleted has the attribute { [[Configurable]]:<b>false</b> } (<es-xref target=
      "sec-delete-operator">12.4.4</es-xref>).</p>
    </li>

    <li>
      <p>It is a <b>SyntaxError</b> if a <i>VariableDeclaration</i> occurs within <es-xref target=
      "sec-strict-mode-code">strict code</es-xref> and its <i>Identifier</i> is <code>eval</code>
      or <code>arguments</code> (<es-xref target="sec-variable-statement">13.2.2</es-xref>).</p>
    </li>

    <li>
      <p>Strict mode code may not include a <i>WithStatement</i>. The occurrence of a
      <i>WithStatement</i> in such a context is an <b>SyntaxError</b> (<es-xref target=
      "sec-with-statement">13.10</es-xref>).</p>
    </li>

    <li>
      <p>It is a <b>SyntaxError</b> if a <es-nt>TryStatement</es-nt> with a <es-nt>Catch</es-nt>
      occurs within <es-xref target="sec-strict-mode-code">strict code</es-xref> and the
      <es-nt>Identifier</es-nt> of the <es-nt>Catch</es-nt> production is <code>eval</code> or
      <code>arguments</code> (<es-xref target="sec-try-statement">13.14</es-xref>)</p>
    </li>

    <li>
      <p>It is a <b>SyntaxError</b> if the identifier <code>eval</code> or <code>arguments</code>
      appears within the <es-nt>FormalParameters</es-nt> of a strict mode
      <es-nt>FunctionDeclaration</es-nt> or <es-nt>FunctionExpression</es-nt> (0)</p>
    </li>

    <li>
      <p>A strict mode function may not have two or more formal parameters that have the same name.
      An attempt to create such a function using a <i>FunctionDeclaration</i>,
      <i>FunctionExpression</i>, or <code>Function</code> constructor is a <b>SyntaxError</b> (0,
      <es-xref target="sec-function-constructor">19.2.1</es-xref>).</p>
    </li>

    <li>
      <p>An implementation may not extend, beyond that defined in this specification, the meanings
      within strict mode functions of properties named <code>caller</code> or
      <code>arguments</code> of function instances. ECMAScript code may not create or modify
      properties with these names on function objects that correspond to strict mode functions
      (<es-xref target="sec-ecmascript-function-objects-getownproperty-p">9.2.2</es-xref>,
      <es-xref target="sec-arguments-exotic-objects">9.4.4</es-xref>).</p>
    </li>

    <li>
      <p>It is a <b>SyntaxError</b> to use within <es-xref target="sec-strict-mode-code">strict
      mode code</es-xref> the identifiers <code>eval</code> or <code>arguments</code> as the
      <i>Identifier</i> of a <i>FunctionDeclaration</i> or <i>FunctionExpression</i> or as a formal
      parameter name (0). Attempting to dynamically define such a strict mode function using the
      <code>Function</code> constructor (<es-xref target=
      "sec-function-constructor">19.2.1</es-xref>) will throw a <b>SyntaxError</b> exception.</p>
    </li>
  </ul>
</es-clause>
