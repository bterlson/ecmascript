<!doctype html>
<es-clause title="AsyncStartLoadPartwayThrough Functions" anchor=
"sec-asyncstartloadpartwaythrough-functions">
  <p>An AsyncStartLoadPartwayThrough function is an anonymous function that is used as a Promise
  executor. When called it creates a new Load Record and populates it with some information
  provided by the caller, so that loading can proceed from either the <code>locate</code> hook, the
  <code>fetch</code> hook, or the <code>translate</code> hook. This functionality is used to
  implement builtin methods like <code><es-xref target=
  "sec-loader.prototype.load">Loader.prototype.load</es-xref></code>, which permits the user to
  specify both the normalized module <es-nt>name</es-nt> and the <es-nt>address</es-nt>.</p>

  <p>Each AsyncStartLoadPartwayThrough function has internal slots [[StepState]].</p>

  <p>When an AsyncStartLoadPartwayThrough function <es-nt>F</es-nt> is called with arguments
  <es-nt>resolve</es-nt> and <es-nt>reject</es-nt>, the following steps are taken:</p>

  <ol class="proc">
    <li>Let <i>state</i> be the value of <i>F</i>â€™s [[StepState]] <es-xref target=
    "sec-object-internal-methods-and-internal-slots">internal slot</es-xref>.</li>

    <li>Let <i>loader</i> be <i>state</i>.[[Loader]].</li>

    <li>Let <i>name</i> be <i>state</i>.[[ModuleName]].</li>

    <li>Let <i>step</i> be <i>state</i>.[[Step]].</li>

    <li>Let <i>source</i> be <i>state</i>.[[ModuleSource]].</li>

    <li>Repeat for each Record {[[key]], [[value]]} <i>p</i> that is an element of <i>loader</i>.[[
    Modules], do

      <ol class="block">
        <li>If <es-xref target="sec-samevalue">SameValue</es-xref>(<i>p</i>.[[key]], <i>name</i>)
        is <b>true</b>, then throw a <b>TypeError</b> exception.</li>
      </ol>
    </li>

    <li>Repeat for element of <i>load</i> or <i>loader</i>.[[ Modules], do

      <ol class="block">
        <li>If <es-xref target="sec-samevalue">SameValue</es-xref>(<i>loads</i>.[[Name]],
        <i>name</i>) is <b>true</b>, then throw a <b>TypeError</b> exception.</li>
      </ol>
    </li>

    <li>Let <i>load</i> be the result of calling the <es-xref target=
    "sec-createload">CreateLoad</es-xref>(<i>name</i>).</li>

    <li>Set <i>load</i>.[[Metadata]] to <i>state</i>.[[ModuleMetadata]].</li>

    <li>Let <i>linkSet</i> be <es-xref target=
    "sec-createlinkset">CreateLinkSet</es-xref>(<i>loader,</i> <i>load</i>).</li>

    <li>Append <i>load</i> to the end of <i>loader</i>.[[Loads]].</li>

    <li>Call the [[Call]] internal method of <i>resolve</i> with arguments <b>undefined</b> and
    (<i>linkSet</i>.[[Done]]).</li>

    <li>If <i>step</i> is <code>"locate"</code>,

      <ol class="block">
        <li>Call <es-xref target="sec-proceedtolocate">ProceedToLocate</es-xref>(<i>loader</i>,
        <i>load</i>).</li>
      </ol>
    </li>

    <li>Else if <i>step</i> is <code>"fetch"</code>,

      <ol class="block">
        <li>Let <i>addressPromise</i> be PromiseOf(<i>state</i>.[[ModuleAddress]]).</li>

        <li>Call <es-xref target="sec-proceedtofetch">ProceedToFetch</es-xref>(<i>loader</i>,
        <i>load</i>, <i>addressPromise</i>).</li>
      </ol>
    </li>

    <li>Else,

      <ol class="block">
        <li><es-xref target="sec-algorithm-conventions">Assert</es-xref>: <i>step</i> is
        <code>"translate"</code>.</li>

        <li>Set <i>load</i>.[[Address]] to <i>state</i>.[[ModuleAddress]].</li>

        <li>Let <i>sourcePromise</i> be PromiseOf(<i>state</i>.[[ModuleSource]]).</li>

        <li>Call <es-xref target=
        "sec-proceedtotranslate">ProceedToTranslate</es-xref>(<i>loader</i>, <i>load</i>,
        <i>sourcePromise</i>).</li>
      </ol>
    </li>
  </ol>
</es-clause>
