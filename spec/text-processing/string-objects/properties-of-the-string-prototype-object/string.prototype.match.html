<!doctype html>
<es-clause title="String.prototype.match (regexp)" anchor="sec-string.prototype.match">
  <p>When the <code>match</code> method is called with argument <es-nt>regexp</es-nt>, the
  following steps are taken:</p>

  <ol class="proc">
    <li>Let <i>O</i> be <es-xref target=
    "sec-checkobjectcoercible">CheckObjectCoercible</es-xref>(<b>this</b> value).</li>

    <li>Let <i>S</i> be <es-xref target="sec-tostring">ToString</es-xref>(<i>O</i>).</li>

    <li><es-xref target="sec-returnifabrupt">ReturnIfAbrupt</es-xref>(<i>S</i>).</li>

    <li>If <es-xref target="sec-ecmascript-data-types-and-values">Type</es-xref>(<i>regexp</i>) is
    Object and <es-xref target="sec-hasproperty">HasProperty</es-xref>(<i>regexp</i>, @@isRegExp)
    is <b>true</b>, then let <i>rx</i> be <i>regexp</i>;</li>

    <li>Else, let <i>rx</i> be the result of the abstract operation <es-xref target=
    "sec-regexpcreate">RegExpCreate</es-xref> (<es-xref target=
    "sec-abstract-operations-for-the-regexp-constructor">21.2.3.3</es-xref>) with arguments
    <i>regexp</i> and <b>undefined</b>.</li>

    <li><es-xref target="sec-returnifabrupt">ReturnIfAbrupt</es-xref>(<i>rx</i>).</li>

    <li>Return the result of Invoke(<i>rx</i>, <code>"match"</code>, ( <i>S</i> )). <i>.</i></li>
  </ol>

  <es-note>
    <p>The <code>match</code> function is intentionally generic; it does not require that its
    <b>this</b> value be a String object. Therefore, it can be transferred to other kinds of
    objects for use as a method.</p>
  </es-note>
</es-clause>
